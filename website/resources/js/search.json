[[{"l":"Welcome","p":["Welcome to the official documentation site for all Konekan plugins. This is the site to read to help you understand our plugins and to find answers to your questions!","If you have any questions about the documentation and wish to get help, join our Discord community by clicking on this link."]},{"l":"Plugins list","p":["Update timeline","Getting started"]}],[{"i":"#","p":["Learn how to enable and start using the plugin."]},{"l":"Blueprint Utilities","p":["Plugin version: v1.0.1 Last documentation update: 03/20/2024","You can simply activate it from the Plugins page Settings - Plugins - BlueprintUtilities."]}],[{"i":"#","p":["Learn how to configure the logging system and how to use it."]},{"l":"Logging system","p":["The logging system of BlueprintUtilities allows you to get rid of all the print string/print text in your project. Thanks to its centralized management in the project settings, you can control all your Log nodes at once. This new system also allows you to bring the power of C++ logs into your blueprint code, enabling you to create logs compatible with shipping builds without leaving blueprint."]},{"l":"Log profiles","p":["Attribute","Bool","Color","Color of the message if the Print to Screen is enabled.","Define where the log node is authorised to log or not. It is based on the who can do more, can do less pattern. It means that if you select Shipping it will print in Shipping, development and editor. To enable log in shipping refer to the Log in shipping section","Description","EBULogPermission","ELogVerbosity","FColor","FGameplayTag","Fname","FString","Human readable identifier used to make it simple for you to find a profile in settings. Also used to log it in error/warning's message.","Identifier","Identifier used to bind a log profile to a Log node.","Log Permission","Name","Prefix","Print to Log","Print to Screen","String to add after the message to log.","String to add before the message to log.","Suffix","The verbosity to use for the message if the Print to Log is enabled.","To use this system properly you need to create some Log profiles. Log profiles represent a logging behavior that you want to use in your project. Log profiles are represented by a name and a FGameplayTag to allow you to assign them to each of your blueprint nodes with one click!","Type","Verbosity","Whether to print or not the message to the logs.","Whether to print or not the message to the screen. Ignored in shipping"]},{"l":"Log in shipping","p":["Before enable log in shipping, ensure you are aware of what your doing. Log in shipping can lead to severe data leaks.","To log in shipping you need to use an Unreal Engine version From source. See : Unreal Engine from source documentation. Then in your project’s Target.cs file add the following lines to force enable the log in shipping."]},{"l":"Example","p":["Once you have finished setting up your log profiles, all that's left is to use the Log node in your project. Easy, isn't it? \uD83D\uDE1C"]}],[{"i":"#","p":["Full list of Get as getters."]},{"l":"GetAs system","p":["The GetAs system is a simple overload of all the getter functions in Unreal Engine that allows you to specify the return class to avoid having to cast the result of the cast every time. All the provided getters are available in both pure (outside the execution thread) and impure (within the execution thread) versions. This page list all implemented getters."]},{"l":"Implemented getters list","p":["Have you found a getter that is not implemented? Join our discord and contact us !"]},{"l":"From None - 3","p":["Get game state as","Get game instance as","Get game mode as"]},{"l":"From Player index - 5","p":["Get player controller as","Get player character as","Get player camera manager as","Get player pawn as","Get player state as"]},{"l":"From AActor - 9","p":["Get owner as","Get parent actor as","Get parent component as","Get AIController as","Get blackboard as","Get instigator controller as","Get root component","Get instigator as","Get level as"]},{"l":"From Controller - 4","p":["Get player state as","Get current path as","Get view target as","Get controlled pawn"]},{"l":"From Player Controller - 4","p":["Get HUD as","Get spectator pawn as","Get player camera manager as","Get cheat manager as"]},{"l":"From Pawn - 6","p":["Get player state as","Get controller as","Get local viewing player controller as","Get movement component as","Get movement base actor as","Get last hit by as"]},{"l":"From Game state - 6","p":["Get authority game mode as","Get player array as"]},{"l":"From Player state - 2","p":["Get player controller as","Get pawn as"]},{"l":"From Other - 2","p":["Get player state from unique net id","Get outer object as"]},{"l":"Dynamic cast","p":["The Dynamic Cast node works just like the native CastTo node in Unreal Engine, with the difference being that it allows you to change the target class without having to replace the node. It's simple and effective."]}],[{"i":"#","p":["Learn how to enable and start using the plugin."]},{"l":"Entity Counting System","p":["Plugin version: v1.0.4 Last documentation update: 01/21/2024"]},{"l":"Plugin activation","p":["To enable the plugin using Blueprint, follows the 4 steps and the restart your editor.","To enable the plugin using C++, add the plugin module name in your public dependencies like following the code."]}],[{"i":"#","p":["Learn wich parent class is the best for you."]},{"l":"Parents classes","p":["To quickly start using the plugin, create an actor with a shaped parent class. See the following Shaped counters section. This will save you from having to unnecessarily manipulate the construction scripts. Either using a Shaped-counter or the Generic-counter, you can create a blueprint or c++ actor from these classes."]},{"l":"Shaped class","p":["Shaped counter’s class are child classes of ECEntityCounter that manipulate the construction script for you by adding a shape component as trigger area and set his collision response accordingly. This will allow you to directly use your counter without going through the construction script stage.","There is three shaped classes :","A counter with a BoxComponent as trigger zone.","A counter with a CapsuleComponent as trigger zone.","A counter with a SphereComponent as trigger zone."]},{"l":"Generic counters","p":["Using the ECEntityCounter, you will be able to use any type of ShapeComponent as trigger zone ()! To do so : add a component inheriting from the class UShapeComponent (UBoxComponent, USphereComponent, UYourCustonShape, YourCustomShapeComponent, ...).","Then call the SetUpCounter metod in your construction script by passing the reference to your component to the method.",".. Or in the same way in C++ constructor method :","This component will represent the area in which entities are counted. (This area will be called the trigger zone for the rest of this documentation)"]}],[{"i":"#","p":["Learn how to setup your counter to make it behave like you want."]},{"i":"counters-configuration","l":"Counter's configuration","p":["Before any counter configuration, don’t forget to enable the Generate overlap event on each counted class or your counter will never trigger an overlap event with them (see image below). Once it’s done, let’s talk about counter configuration …","The ECEntityCounter class offers a whole range of parameters allowing you to modify the behavior of the counter. All of these parameters are marked as EditAnywhere, so you can configure your counter in your main Blueprint class or individually in each of the instances placed in the world. All parameters can be changed at runtime without restarting the counter.","In this section, I suggest you to pay attention to the logic you want to implement. Some combinations of parameters can sometimes block the counter if you are not careful e.g. : If CanIncrement and CanDecrement are false, the counter will never change…","Here is the full list and details about each parametters :"]},{"i":"global-parameters","l":"Global Parameters :","p":["If true, the counter will start detection right after the SetUpCounter if the actor is in game or it will wait for the BeginPlay.","If true, the counter will count the entity only once, else, it will count the entity each-time it enters the trigger zone..→ details : if CanDecrement is true and the entity leaves the trigger zone, it will be removed from the list and it will count again if it crosses the trigger zone another time."]},{"i":"counting-behavior-parameters","l":"Counting behavior parameters:","p":["The initial value of the counter.","The value used to increment or decrement the counter for each entity by default.","If true, the counter will increment if a countable entity enters in the trigger zone.","If true, the counter will decrease if a countable entity leaves the trigger zone."]},{"i":"tracked-entities-parameters","l":"Tracked Entities parameters :","p":["List of actor’s class to ignore when detecting entities. Leave it empty to ignore nothing.","If true, the overlapping actor class will be tested with an exact match. It means only the exact class will be ignored and not child classes.","Map of actor’s class to count when detecting entities. Leave it empty to count every class. The key represents the class and the value represents the custom increment value used if UseClassesIncrementOverride is true.","If true, the overlapping actor class will be tested with an exact match. It means only the exact class will be counted and not child classes.","If true, the counter will use a custom counting value for each CountedClasses stored in the map ActorClassesToCount to increment or decrement the count value."]},{"i":"steps-parameters","l":"Steps parameters:","p":["If true, the counter will trigger the event OnCountReachStep when the counter reaches a step.","List containing each step of this counter.","If true, the counter will fire the OnCountReachStep event if the count reaches a step during an incrementing phase.","If true, the counter will fire the OnCountReachStep event if the count reaches a step during a decrementing phase.","If true, the counter will fire each step event only once at the first time it reaches the step.","If true, if the counter skips a step due to an increment (or decrement) it will fire all skipped step events according to the UserCroissantOrderForRetroactiveStepEvent variable.→ E.g. The count is 0 and it has the following steps : 5,8,10. If the count gains +10, it will skip step 5 and 8. By allowing this parameter the counter will fire step 5, step 8 and then step 10 on the same frame to prevent you from skipping steps. If you want the same behavior but triggering only Greater steps you must uncheck the UserCroissantOrderForRetroactiveStepEvent variable.","If true, retroactive step events will be fired in decreasing order using the current count as lowest step value to fire."]},{"i":"goal-parameters","l":"Goal parameters:","p":["If true, the count will fire the OnCountReachGoal event when the counter reaches his goal.","The goal value.","This parameter specifies the way you want to confront the current count of the counter to the Goal. There is one enum value for each type of test (<, <=, ==, >=, >).","If true, the counter will automatically stop the entity detection when it reaches the goal.","If true, the OnCountReachGoal event will fire only the first time it meets the goal."]}],[{"i":"#","p":["Learn how to counters broadcast events and how to bind your code to them."]},{"i":"counters-events","l":"Counter's events","p":["The ECEntityCounter class has 4 events replicated to all clients (server authoritative). These four events are public and can be used from C++ code or from Blueprint.","Some events are only propagated if the counter's configuration allows it. See Counter's configuration (Steps and Goals)"]},{"l":"Events","p":["OnEntityAdded(AActor* NewEntity, int32 NewCount): Fired every time an entity is added to the count.","OnEntityRemoved(AActor* RemovedEntity, int32 NewCount): Fired every time an entity is removed from the count.","OnCountReachStep(int32 Step): Fired when the counter reaches a step and gives the step value as parameter.","OnCoutReachGoal(): Fired when the counter reaches the goal."]},{"l":"Bindings","p":["To easily bind your events in your blueprint actor you can use the blueprint implementable version of the event. To do so, on the right side of the FUNCTIONS section, click on override and select the event you want to implement.","Once clicked it will generate the blueprint nodes allowing you to implement this event in your actor.","Sometimes it will generate a function instead of an event. In this case, simply right-click on the function node and select “convert to event”.","In C++ code, just get your EntityCounter actor and bind a callback to the public delegate associated with the event you need."]}]]