[[{"l":"Welcome","p":["Welcome to the official documentation site for all Konekan plugins. This is the site to read to help you understand our plugins and to find answers to your questions!","If you have any questions about the documentation and wish to get help, join our Discord community by clicking on this link."]},{"l":"Plugins list","p":["Update timeline","Getting started"]}],[{"i":"#","p":["Learn how to enable and start using the plugin."]},{"l":"Blueprint Utilities","p":["Plugin version: v2.0.0 Last documentation update: 05/13/2024","You can simply activate it from the Plugins page Settings - Plugins - BlueprintUtilities."]}],[{"i":"#","p":["Learn how to configure the logging system and how to use it."]},{"l":"Logging system","p":["The logging system of Blueprint Utilities allows you to get rid of all the print string/print text in your project. Thanks to its centralized management in the project settings, you can control all your Log nodes at once. This new system also allows you to bring the power of C++ logs into your blueprint code, enabling you to create logs compatible with shipping builds without leaving blueprint."]},{"l":"The Log node","p":["The Log node has two static input pins. The first one is a FGameplayTag selector that represent the LogProfile associated to this node, and the second one is Message pin that contain the string to print.","The Message pin will transform any expression surounded with {} into an argument pin."]},{"l":"Log profiles","p":["Attribute","Bool","Color","Color of the message if the Print to Screen is enabled.","Define where the log node is authorised to log or not. It is based on the who can do more, can do less pattern. It means that if you select Shipping it will print in Shipping, development and editor. To enable log in shipping refer to the Log in shipping section","Description","EBULogPermission","ELogVerbosity","FColor","FGameplayTag","Fname","FString","Human readable identifier used to make it simple for you to find a profile in settings. Also used to log it in error/warning's message.","Identifier","Identifier used to bind a log profile to a Log node.","Log Permission","Name","Prefix","Print to Log","Print to Screen","String to add after the message to log.","String to add before the message to log.","Suffix","The verbosity to use for the message if the Print to Log is enabled.","To use this system properly you need to create some Log profiles. Log profiles represent a logging behavior that you want to use in your project. Log profiles are represented by a name and a FGameplayTag to allow you to assign them to each of your blueprint nodes with one click!","Type","Verbosity","Whether to print or not the message to the logs.","Whether to print or not the message to the screen. Ignored in shipping"]},{"l":"Other Settings","p":["Attribute","Type","Description","Display profile's name in node title","Bool","If true, the LogProfile name will be display in the node title. E.g.: Log - MyCustomLogProfile","Should error if no profile selected","If true, any Log node with no LogProfile selected will trigger an error during blueprint compilation.","Log node color","FColor","The default color of the Log node.","Disabled node color","The color of the node when his associated LogProfile is disabled."]},{"l":"Log in shipping","p":["Before enable log in shipping, ensure you are aware of what your doing. Log in shipping can lead to severe data leaks.","To log in shipping you need to use an Unreal Engine version From source. See : Unreal Engine from source documentation. Then in your project’s Target.cs file add the following lines to force enable the log in shipping."]},{"l":"Example","p":["Once you have finished setting up your log profiles, all that's left is to use the Log node in your project. Easy, isn't it? \uD83D\uDE1C"]}],[{"i":"#","p":["Full list of Get as getters."]},{"l":"GetAs system","p":["The GetAs system is a simple overload of all the getter functions in Unreal Engine that allows you to specify the return class to avoid having to cast the result of the cast every time. All the provided getters are available in both pure (outside the execution thread) and impure (within the execution thread) versions. This page list all implemented getters."]},{"l":"Accessibility","p":["Every node of the GetAs system allows you to convert them between pure and impure mode in the context menu. As well as the purity option, all getters that take a target as input can switch between hard and soft pointer in the same context menu."]},{"l":"Implemented getters list","p":["Have you found a getter that is not implemented? Join our discord and contact us !"]},{"l":"From None - 3","p":["Get game state as","Get game instance as","Get game mode as"]},{"l":"From Player index - 5","p":["Get player controller as","Get player character as","Get player camera manager as","Get player pawn as","Get player state as"]},{"l":"From AActor - 9","p":["Get owner as","Get parent actor as","Get parent component as","Get AIController as","Get blackboard as","Get instigator controller as","Get root component","Get instigator as","Get level as"]},{"l":"From Controller - 4","p":["Get player state as","Get current path as","Get view target as","Get controlled pawn"]},{"l":"From Player Controller - 4","p":["Get HUD as","Get spectator pawn as","Get player camera manager as","Get cheat manager as"]},{"l":"From Pawn - 6","p":["Get player state as","Get controller as","Get local viewing player controller as","Get movement component as","Get movement base actor as","Get last hit by as"]},{"l":"From Game state - 6","p":["Get authority game mode as","Get player array as"]},{"l":"From Player state - 2","p":["Get player controller as","Get pawn as"]},{"l":"From Other - 2","p":["Get player state from unique net id","Get outer object as"]},{"l":"Dynamic cast","p":["The Dynamic Cast node works just like the native CastTo node in Unreal Engine, with the difference being that it allows you to change the target class without having to replace the node. It's simple and effective."]}],[{"i":"#","p":["Workflow library presentation."]},{"l":"Workflow library","p":["Workflow library of the BlueprintUtilities plugin is containing a list of node that help you to improve your blueprint workflow."]},{"l":"Timed Do Once","p":["The Timed Do Once node behave like the vanilla Do Once node except it allows you to give a duration after which the node will be automatically \"unlock\".","Main input pin of the node. Used to triger the Do output execution pin.","Alternative input pin used to manualy \"unlock\" the node allowing you to trigger the Do output execution pin again. If the timer is running it will be stop and clear.","The perdiod to wait before \"unlicking\" the node.","If true, the node will reject the first execution. The first execution will start the timer.","If true, the timer will start only after execution until it \"unlock\"the node or being manually reset and will be auto-cleared after the node \"unlocked\".","If failse, the timer will run continuouslly and will \"unlock\"the node each time it reach the Duration.","Ouput pin triggered when the Exec input pin is triggered and the node is open."]}],[{"i":"#","p":["Imrpove your math experience with blueprintUtilitites math library."]},{"l":"Math library","p":["The math library of Blueprint Utilities provides new nodes to simplify scripting complex operations. The main goal of this library is to consolidate frequently used operations, such as the\\frac{1}{x} function, into a single node, without duplicating native Unreal Engine nodes."]},{"l":"Node list"},{"l":"MIN","p":["The MIN node return the smallest value of the selected type.","Return the smallest value of the selected type.","Right click on this pin to select manualy the type of the node. (see screen above)"]},{"l":"MAX","p":["The MAX node return the highest value of the selected type.","Return the highest value of the selected type.","Right click on this pin to select manualy the type of the node. (see screen above)"]},{"l":"Oposit","p":["The Oposit (-) node return the input value times -1.","The value to compute","The result of A \\times -1"]},{"l":"Invert","p":["The Invert (1/x) node return 1 devided by the input value.","The value to compute.","If A is 0 then the node return 0 and raise and division error.","The result of \\frac{1}{A}"]},{"l":"Spaceship operator","p":["The Spaceship Operator = is the same as the operator from Perl, Ruby and C++ 20. Full explenation on the wikipedia page","Main input pin of the node","The first value to use in the three ways comparaison operator.","The second value to use in the three ways comparaison operator.","Ouput pin triggered when A B.","Ouput pin triggered when A == B.","Result value of the operator returned to allow the user to use it without creating a new tempoary variable."]},{"l":"Plus equal operator","p":["The += node behave like the C+++= operator. It take the B value and add it to A and set the new value to the variable A: A += B= A = A + B.","Main input pin of the node.","Reference to the variable you want to update.","The value used as right-value in the operation.","Ouput execution pin.","The new value of A after the assignment. Same as a fresh new get."]},{"l":"Substract equal operator","p":["The -= node behave like the C++-= operator. It take the B value and substract it to A and set the new value to the variable A: A -= B= A = A - B.","Main input pin of the node.","Reference to the variable you want to update.","The value used as right-value in the operation.","Ouput execution pin.","The new value of A after the assignment. Same as a fresh new get."]},{"l":"Multiply equal operator","p":["The *= node behave like the C++*= operator. It take the B value and multiply with A and set the new value to the variable A: A *= B= A = A * B.","Main input pin of the node.","Reference to the variable you want to update.","The value used as right-value in the operation.","Ouput execution pin.","The new value of A after the assignment. Same as a fresh new get."]},{"l":"Devide equal operator","p":["The /= node behave like the C++/= operator. It take the A value and devide it with B and set the new value to the variable A: A /= B= A = A / B.","Main input pin of the node.","Reference to the variable you want to update.","The value used as right-value in the operation.","Ouput execution pin.","The new value of A after the assignment. Same as a fresh new get."]},{"l":"Greater or Nearly Equal","p":["The Greater or Nearly Equal ≈ node return true if the A is superior to B or is nearly equal to B (using the error tolerance value): A ≈ B is same as A (B - ErrorTolerance)","The value that will be compared.","The value A will be compared to.","The precision value is used to determine if A is considered equal to B.","True if A ≈ B."]},{"l":"Less or Nearly Equal","p":["The Less or Nearly Equal ≈ node return true if the A is less than B or is nearly equal to B (using the error tolerance value): A ≈ B is same as A (B + ErrorTolerance)","The value that will be compared.","The value A will be compared to.","The precision value is used to determine if A is considered equal to B.","True if A ≈ B."]}],[{"i":"#","p":["All last updates for each version of the plugin"]},{"l":"Changelog"},{"i":"v20","l":"V2.0"},{"l":"V2.0.0","p":["Two new modules (! runtime and 1 UncookedOnly) to support the Maths library.","11 new nodes to improve the math experience with Blueprint. Min, Max, Invert, Oposit, Spaceship operator (=), +=, -=, *=, /=, Greater or Nearly Equal and Less or Nearly Equal"]},{"l":"V2.0.0","p":["The plugin code has been spited in submodule to allow editor and runtime features to be compiled independently.","Huge code refractoring reducing the duplicated code.","Performance updates and general code cleanup.","All 37 Getters refarctored to use Kismet.","Dynamic cast refarctored to use Kismet.","All nodes of the module can be converted to pure/impure mode with a click in the context menu.","Nodes with a target object can be converted to hard/soft pointer input type with a click in the context menu.","New project settings ( Display profile's name in node title, Should error if no profile selected, Log node color, Disabled node color).","The Log node refarctored to use kismet.","The Log node now implement a format system like the FormatText node.","The Log node now change of style and title according to the selected log profile."]},{"i":"v10","l":"V1.0"},{"l":"V1.0.5","p":["The plugin code has been setup in modules to improve code maintanability.","New platforms supported : Linux and Android.","37 Getters implemented with 3 forms: Pure, Impure, SoftRef based","Dynamic cast node with 2 forms: Pure, Impure","The log system is user created log profiles based and support all build environement type (Editor, Development (and debug), Shipping)","The first node of the library added is TimedDoOnce."]}],[{"i":"#","p":["Learn how to enable and start using the plugin."]},{"l":"Entity Counting System","p":["Plugin version: v1.0.5 Last documentation update: 05/13/2024"]},{"l":"Plugin activation","p":["To enable the plugin using Blueprint, follows the 4 steps and the restart your editor.","To enable the plugin using C++, add the plugin module name in your public dependencies like following the code."]}],[{"i":"#","p":["Learn wich parent class is the best for you."]},{"l":"Parents classes","p":["To quickly start using the plugin, create an actor with a shaped parent class. See the following Shaped counters section. This will save you from having to unnecessarily manipulate the construction scripts. Either using a Shaped-counter or the Generic-counter, you can create a blueprint or c++ actor from these classes."]},{"l":"Shaped class","p":["Shaped counter’s class are child classes of ECEntityCounter that manipulate the construction script for you by adding a shape component as trigger area and set his collision response accordingly. This will allow you to directly use your counter without going through the construction script stage.","There is three shaped classes :","A counter with a BoxComponent as trigger zone.","A counter with a CapsuleComponent as trigger zone.","A counter with a SphereComponent as trigger zone."]},{"l":"Generic counters","p":["Using the ECEntityCounter, you will be able to use any type of ShapeComponent as trigger zone ()! To do so : add a component inheriting from the class UShapeComponent (UBoxComponent, USphereComponent, UYourCustonShape, YourCustomShapeComponent, ...).","Then call the SetUpCounter metod in your construction script by passing the reference to your component to the method.",".. Or in the same way in C++ constructor method :","This component will represent the area in which entities are counted. (This area will be called the trigger zone for the rest of this documentation)"]}],[{"i":"#","p":["Learn how to setup your counter to make it behave like you want."]},{"i":"counters-configuration","l":"Counter's configuration","p":["Before any counter configuration, don’t forget to enable the Generate overlap event on each counted class or your counter will never trigger an overlap event with them (see image below). Once it’s done, let’s talk about counter configuration …","The ECEntityCounter class offers a whole range of parameters allowing you to modify the behavior of the counter. All of these parameters are marked as EditAnywhere, so you can configure your counter in your main Blueprint class or individually in each of the instances placed in the world. All parameters can be changed at runtime without restarting the counter.","In this section, I suggest you to pay attention to the logic you want to implement. Some combinations of parameters can sometimes block the counter if you are not careful e.g. : If CanIncrement and CanDecrement are false, the counter will never change…","Here is the full list and details about each parametters :"]},{"i":"global-parameters","l":"Global Parameters :","p":["If true, the counter will start detection right after the SetUpCounter if the actor is in game or it will wait for the BeginPlay.","If true, the counter will count the entity only once, else, it will count the entity each-time it enters the trigger zone..→ details : if CanDecrement is true and the entity leaves the trigger zone, it will be removed from the list and it will count again if it crosses the trigger zone another time."]},{"i":"counting-behavior-parameters","l":"Counting behavior parameters:","p":["The initial value of the counter.","The value used to increment or decrement the counter for each entity by default.","If true, the counter will increment if a countable entity enters in the trigger zone.","If true, the counter will decrease if a countable entity leaves the trigger zone."]},{"i":"tracked-entities-parameters","l":"Tracked Entities parameters :","p":["List of actor’s class to ignore when detecting entities. Leave it empty to ignore nothing.","If true, the overlapping actor class will be tested with an exact match. It means only the exact class will be ignored and not child classes.","Map of actor’s class to count when detecting entities. Leave it empty to count every class. The key represents the class and the value represents the custom increment value used if UseClassesIncrementOverride is true.","If true, the overlapping actor class will be tested with an exact match. It means only the exact class will be counted and not child classes.","If true, the counter will use a custom counting value for each CountedClasses stored in the map ActorClassesToCount to increment or decrement the count value."]},{"i":"steps-parameters","l":"Steps parameters:","p":["If true, the counter will trigger the event OnCountReachStep when the counter reaches a step.","List containing each step of this counter.","If true, the counter will fire the OnCountReachStep event if the count reaches a step during an incrementing phase.","If true, the counter will fire the OnCountReachStep event if the count reaches a step during a decrementing phase.","If true, the counter will fire each step event only once at the first time it reaches the step.","If true, if the counter skips a step due to an increment (or decrement) it will fire all skipped step events according to the UserCroissantOrderForRetroactiveStepEvent variable.→ E.g. The count is 0 and it has the following steps : 5,8,10. If the count gains +10, it will skip step 5 and 8. By allowing this parameter the counter will fire step 5, step 8 and then step 10 on the same frame to prevent you from skipping steps. If you want the same behavior but triggering only Greater steps you must uncheck the UserCroissantOrderForRetroactiveStepEvent variable.","If true, retroactive step events will be fired in decreasing order using the current count as lowest step value to fire."]},{"i":"goal-parameters","l":"Goal parameters:","p":["If true, the count will fire the OnCountReachGoal event when the counter reaches his goal.","The goal value.","This parameter specifies the way you want to confront the current count of the counter to the Goal. There is one enum value for each type of test (<, <=, ==, >=, >).","If true, the counter will automatically stop the entity detection when it reaches the goal.","If true, the OnCountReachGoal event will fire only the first time it meets the goal."]}],[{"i":"#","p":["Learn how to counters broadcast events and how to bind your code to them."]},{"i":"counters-events","l":"Counter's events","p":["The ECEntityCounter class has 4 events replicated to all clients (server authoritative). These four events are public and can be used from C++ code or from Blueprint.","Some events are only propagated if the counter's configuration allows it. See Counter's configuration (Steps and Goals)"]},{"l":"Events","p":["OnEntityAdded(AActor* NewEntity, int32 NewCount): Fired every time an entity is added to the count.","OnEntityRemoved(AActor* RemovedEntity, int32 NewCount): Fired every time an entity is removed from the count.","OnCountReachStep(int32 Step): Fired when the counter reaches a step and gives the step value as parameter.","OnCoutReachGoal(): Fired when the counter reaches the goal."]},{"l":"Bindings","p":["To easily bind your events in your blueprint actor you can use the blueprint implementable version of the event. To do so, on the right side of the FUNCTIONS section, click on override and select the event you want to implement.","Once clicked it will generate the blueprint nodes allowing you to implement this event in your actor.","Sometimes it will generate a function instead of an event. In this case, simply right-click on the function node and select “convert to event”.","In C++ code, just get your EntityCounter actor and bind a callback to the public delegate associated with the event you need."]}]]